{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/typescript/differences-between-type-aliases-and-interfaces","result":{"data":{"post":{"__typename":"MdxPost","slug":"/typescript/differences-between-type-aliases-and-interfaces","title":"[Typescript] Differences Between Type Aliases and Interfaces, Type과 Interface 차이점","date":"2021.06.09","tags":[{"name":"Typescript","slug":"typescript"},{"name":"Type","slug":"type"},{"name":"Interface","slug":"interface"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"[Typescript] Differences Between Type Aliases and Interfaces, Type과 Interface 차이점\",\n  \"date\": \"2021-06-09T00:00:00.000Z\",\n  \"tags\": [\"Typescript\", \"Type\", \"Interface\"],\n  \"slug\": \"typescript/differences-between-type-aliases-and-interfaces\",\n  \"banner\": \"/images/ts-banner.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"\\uC694\\uC57D\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type\\uACFC Interface\\uB294 \\uAC70\\uC758 \\uBAA8\\uB4E0 \\uAE30\\uB2A5\\uC774 \\uC720\\uC0AC\\uD558\\uB2E4. \\uB300\\uBD84\\uBD84\\uC758 \\uACBD\\uC6B0 \\uCDE8\\uD5A5\\uC5D0 \\uB530\\uB77C \\uC120\\uD0DD \\uAC00\\uB2A5.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type\\uC740 Declare merging \\uBD88\\uAC00\\uB2A5. \\uADF8\\uB7EC\\uB098 Interface\\uB294 \\uAC00\\uB2A5\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interface\\uB294 object \\uD615\\uC2DD\\uB9CC \\uC120\\uC5B8\\uD560 \\uC218 \\uC788\\uACE0 Primitive type\\uC740 \\uC120\\uC5B8\\uD560 \\uC218 \\uC5C6\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC5D0\\uB7EC\\uBA54\\uC138\\uC9C0\\uC5D0\\uC11C Interface\\uB294 \\uC774\\uB984\\uC774 \\uB098\\uC624\\uC9C0\\uB9CC Type\\uC740 \\uC774\\uB984\\uC774 \\uC548\\uB098\\uC628\\uB2E4.\")), mdx(\"h2\", null, \"\\uAC19\\uC740 \\uAE30\\uB2A5 - Type\\uACFC Interface \\uD0C0\\uC785 \\uD655\\uC7A5\"), mdx(\"h3\", null, \"Extending an interface\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"interface Animal {\\n  name: string;\\n}\\n\\ninterface Bear extends Animal {\\n  honey: boolean;\\n}\\n\\nconst bear = getBear();\\nbear.name;\\nbear.honey;\\n\")), mdx(\"h3\", null, \"Extending a type via intersections\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"interface Animal {\\n  name: string;\\n}\\n\\ninterface Bear extends Animal {\\n  honey: boolean;\\n}\\n\\nconst bear = getBear();\\nbear.name;\\nbear.honey;\\n\")), mdx(\"h2\", null, \"Declare merging - \\uC0C8\\uB85C\\uC6B4 \\uD544\\uB4DC\\uB97C \\uCD94\\uAC00\\uD560 \\uB54C Interface\\uB294 \\uAC00\\uB2A5\\uD558\\uC9C0\\uB9CC Type\\uC740 \\uC548\\uB41C\\uB2E4.\"), mdx(\"h3\", null, \"Adding new fields to an existing interface\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"interface Bear {\\n  name: string;\\n}\\n\\ninterface Bear {\\n  honey: boolean;\\n}\\n\\nconst bear: Bear = {\\n  name: \\\"teddy\\\",\\n  honey: true,\\n};\\n\\nconsole.log(bear);\\n\\n// [LOG]: {\\n//   \\\"name\\\": \\\"teddy\\\",\\n//   \\\"honey\\\": true\\n// }\\n\")), mdx(\"h3\", null, \"A type cannot be changed after being created\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"type Bear = {\\n  name: string;\\n};\\n\\ntype Bear = {\\n  honey: boolean;\\n};\\n\\n// Error: Duplicate identifier 'Bear'.\\n\")), mdx(\"h2\", null, \"Declare the shapes of object, Not re-name primirives\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"type SomeNumber = number;\\ninterface MyNumber {\\n  number: number;\\n}\\n\\ninterface SomeType extends number {} // X\\n\")), mdx(\"h2\", null, \"\\uC5D0\\uB7EC\\uBA54\\uC138\\uC9C0\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"interface Mammal {\\n  name: string;\\n}\\n\\nfunction echoMammal(m: Mammal) {\\n  console.log(m.name);\\n}\\n\\nechoMammal({ name: 12343 }); // Error: (property) Mammal.name: string\\n\\ntype MammalType = { name: string };\\nfunction echoAnimal(m: MammalType) {\\n  console.log(m.name);\\n}\\n\\nechoAnimal({ name: 12345 }); // Error: (property) name: string\\n\")), mdx(\"h2\", null, \"\\uCC38\\uACE0\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces\"\n  }), \"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"요약 Type과 Interface는 거의 모든 기능이 유사하다. 대분분의 경우 취향에 따라 선택 가능. Type은 Declare merging 불가능. 그러나 Interface는 가능 Interface는 object…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/typescript/differences-between-type-aliases-and-interfaces","formatString":"YYYY.MM.DD"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}